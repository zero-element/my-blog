---
title: "从零知识证明到ETH智能合约"
date: 2021-04-17
draft: true
description: "很好玩，又有点难玩，这是个哲学"
categories: [
  "开发"
]
tags: [
  "区块链"
]
---

# 零知识证明

## 什么是零知识证明

零知识证明指的是，证明者能够在不向验证者提供任何有用的信息的情况下，使验证者相信某个论断是正确的——存在一个双方已知的问题，我虽然知道答案，但不能透露答案是什么，同时证明我确实知道这个答案。

而当下应用最广泛的零知识证明被称为**zk-SNARK**(Zero-Knowledge Succinct Non-Interactive Argument of Knowledge)，即“零知识”、“简洁”、“非交互性”的“知识证明”，这几个要素可以通过模块化的方式逐步构建。

### 知识证明

#### 简单的例子

![alibaba](.\alibaba.jpg)

> 1.强盗在A点站立，并让阿里巴巴走到B点，阿里巴巴随机的从左右两个方向进入洞穴，因此阿里巴巴可能到达C处，也可能到达D处
> 2.强盗走到B点，并随机让阿里巴巴从左边或从右边出来。如果阿里巴巴拥有密门的咒语，那么无论他现在在C点或者是在D点都可以按照强盗的指令从正确的方向走出洞穴；但如果阿里巴巴如果没有密门的咒语，那么他只有$\frac{1}{2}$的可能从正确的方向出来

在这个场景下，通过k轮检查的概率为$(\frac{1}{2})^k$，只要通过足够多轮次的检查，就有极大的把握证明阿里巴巴拥有密门的咒语。

#### PCP定理

PCP，全称Probabilistically Checkable Proof，意思就是，所有的NP问题，都可以在多项式时间内通过概率验证的方法被证明。

因为**所有的NP问题都可以有效地转换为数学运算电路**，PCP定理指出，对于所有的电路![[公式]](https://www.zhihu.com/equation?tex=C)，我们都可以构造一套概率验证体系![[公式]](https://www.zhihu.com/equation?tex=%28S%2C+P%2C+V%29)，其工作方式如下：

![[公式]](.\PCP.svg)

S为生成算法Setup，把电路C转换成后续会用到的随机参数。

![img](.\证明体系.png)

> 证明方通过公有和私密输入生成一个证明$\pi$，并且把证明$\pi$**存入只读区域后共享给验证方查看**（只读区域可以防止双方篡改证明内容）。**唯一不同的是验证方并不能看到所有的$\pi$，只能通过一个query机制来检查这个证明$\pi$随机的$k$位数**。通过看完这$k$位数之后，验证方就需要输出验证结果。

### 简洁性

#### 从PCP到LPCP

换一个实际一点的例子

> 假如A需要向B证明她拥有一个从0到100依次升序排列的数组，那么B可以通过随机抽查的方式来验证A的数组是否正确排列。
>
> B可以抽查第49位是不是48，第3位是不是2等等来确定A是否真的拥有这么一个数组。当然，A也有可能是运气好，除了第49位和第3位其他都是乱序的。
>
> 不过当抽查的次数越来越多，A作假的可能性也会越来越低。

但是，这种单纯的抽查效率是非常低下的，验证的确信程度随着抽查次数线性提高，想要接近100%的确认就需要整个数组，开销不可接受，因此需要引**线性PCP（Linear PCP/LPCP）**

如果说PCP形容的是所有NP范围内的问题都可以通过简短的随机抽验来验证，LPCP则是说**任意一个$d$阶的多项式$P$，都可以通过随机验证多项式在几个点上取值来确定这个多项式的每一项系数是否满足特定的要求**。

#### Merkle Tree

~~虽然这里用不到，但是merkle tree是一个匿名货币中非常常用的技术~~

![merkle tree](.\merkle tree.png)

merkle tree是一种二叉哈希树，构建方式如上，常用于检验数据的完整性——其优势在于不需要下载完整的数据或者merkle tree，便可检验一个数据块是否属于整个数据。

##### Merkle证明

![merkle proof](C:\Users\zeroemt\Documents\my-blog\content\post\从零知识证明到ETH智能合约\merkle proof.png)

### 非交互

#### Fiat-Shamir Heuristic

~~这里同样用不上~~

Fiat-Shamir Heuristic是一个基于随机预言机假设的启发法，**可以把任何交互式的随机验证协议(Public-coin Protocol)转换为非交互式的协议**。

**随机预言机**，是一种理想机器，无论输入的是什么，输出的值我们都可以看作是一个和输入没有关联的随机数。这里用到的假设是**哈希函数是随机预言机**（未证明，但好用）

#### CRS模型

**公共参考字串（CRS）**其实是一个相比起随机预言机更为简单的假设，具体是这样的：

> 我们假设在一个协议中，证明方与验证方都**拥有一段相同的参考字串**。这个字串可能是随机生成的，也可能是某个函数的输出。重要的是完成协议的两方并不知道这个字串具体是如何被生成的，就感觉像是**天上掉下来的**一样。

通过CRS假设，我们可以得到一串随机的字符串作为随机数种子，在交互过程中双方可以通过这个公共种子生成公共的挑战。但是，直接共享明文的字串会让证明者可以预知自己的挑战，进而根据挑战作弊。同时，在裸露的LPCP体系下，证明方需要将完整的证明π传给验证者，违背了“零知识”的前提。

因此，无论是初始的CRS，还是后续的整体运算都需要在加密空间下进行，而且这层加密应当是不可解的。特别的是，这里的加密方式需要保证，加密后的字串[[a]]具有与原字串a具有相同（至少具备LPCP所需的）的运算性质。这样，这层加密可以无缝地融入原有的LPCP体系，验证方无需解密即可直接检验证明。

### 零知识

#### 同态加密



# ETH智能合约

## Solidity



## Zokrates



# 安全问题

## 输入假名